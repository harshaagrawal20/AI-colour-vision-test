<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Color Vision AI Testing System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
        }

        .upload-area input {
            display: none;
        }

        .upload-area-text {
            font-size: 1.2em;
            color: #667eea;
            margin-bottom: 10px;
        }

        .upload-area-hint {
            color: #999;
            font-size: 0.9em;
        }

        .hidden {
            display: none !important;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .test-container {
            margin-top: 30px;
        }

        .patch-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
            justify-content: center;
        }

        .patch {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: grab;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .patch:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .patch.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .ordering-zone {
            background: #f8f9ff;
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 15px;
            min-height: 100px;
            margin: 20px 0;
            overflow-x: auto;
        }

        .ordered-patches {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            align-items: center;
            min-width: max-content;
        }

        .ordered-patch {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 6px;
            border: 2px solid #667eea;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .ordered-patch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .empty-slot {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 6px;
            border: 2px dashed #667eea;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #667eea;
            font-size: 0.7em;
            font-weight: bold;
        }

        .empty-slot:hover {
            background: #f0f4ff;
            border-color: #5566dd;
        }

        .empty-slot.drag-over {
            background: #e8f0ff;
            border-color: #4455cc;
            transform: scale(1.05);
        }

        .patch.used {
            opacity: 0.3;
            pointer-events: none;
            cursor: not-allowed;
        }

        .patch-index {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .button-secondary {
            background: #666;
        }

        .button-secondary:hover {
            box-shadow: 0 6px 12px rgba(102, 102, 102, 0.4);
        }

        .results-container {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 30px;
            margin-top: 30px;
        }

        .result-card {
            background: white;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .result-title {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .result-value {
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .severity-mild {
            color: #4CAF50;
        }

        .severity-moderate {
            color: #FF9800;
        }

        .severity-severe {
            color: #F44336;
        }

        .recommendation {
            background: #fff3e0;
            border-left: 4px solid #FF9800;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            color: #555;
            line-height: 1.6;
        }

        /* Gemini AI Analysis Styles */
        .gemini-analysis {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border: 2px solid #4285F4;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.1);
        }

        .gemini-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .gemini-header h3 {
            margin: 0;
            color: #1a73e8;
            font-size: 1.3em;
            font-weight: 600;
        }

        .gemini-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            color: #333;
            line-height: 1.8;
            font-size: 0.95em;
            white-space: pre-wrap;
            max-height: 600px;
            overflow-y: auto;
        }

        .gemini-content h4 {
            color: #1a73e8;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .gemini-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .gemini-content li {
            margin-bottom: 8px;
        }

        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4285F4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .gemini-error {
            color: #d32f2f;
            padding: 15px;
            background: #ffebee;
            border-radius: 6px;
            border-left: 4px solid #d32f2f;
        }

        .chart-container {
            margin-top: 20px;
            text-align: center;
        }

        .probability-bar {
            margin: 15px 0;
        }

        .probability-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .probability-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 25px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #c62828;
        }

        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #2e7d32;
        }

        .info-text {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            line-height: 1.5;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .patch-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® D-15 Color Vision AI Testing System</h1>
            <p>Upload an image and arrange 15 color patches to test your color perception with similar hues</p>
        </div>

        <!-- Step 1: Upload Image -->
        <div class="section" id="upload-section">
            <div class="section-title">Step 1: Upload an Image</div>
            <div class="upload-area" id="upload-area">
                <div class="upload-area-text">üì∏ Drop your image here or click to select</div>
                <div class="upload-area-hint">Supported: JPG, PNG, WebP (any natural image)</div>
                <input type="file" id="file-input" accept="image/*">
            </div>
            <div id="upload-error" class="error-message hidden"></div>
            <div id="upload-loading" class="loading hidden">
                <div class="spinner"></div>
                <p>Extracting colors and generating test...</p>
            </div>
        </div>

        <!-- Step 2: Take Test -->
        <div class="section hidden" id="test-section">
            <div class="section-title">Step 2: Arrange the Colors</div>
            <div class="info-text">
                Drag and drop the 15 color patches below to arrange them in the order you think is correct.
                This D-15 test evaluates your color perception accuracy with similar hues and shades.
            </div>
            
            <div class="test-container">
                <div style="margin-bottom: 20px;">
                    <div style="font-weight: bold; color: #667eea; margin-bottom: 10px;">Available Colors:</div>
                    <div class="patch-grid" id="patch-grid"></div>
                </div>

                <div style="font-weight: bold; color: #667eea; margin-bottom: 10px;">Your Order:</div>
                <div class="ordering-zone" id="ordering-zone">
                    <div class="ordered-patches" id="ordered-patches"></div>
                </div>
            </div>

            <div id="test-error" class="error-message hidden"></div>

            <div class="button-group">
                <button class="button" id="submit-btn" disabled>Submit Response</button>
                <button class="button button-secondary" id="reset-btn">Reset</button>
                <button class="button button-secondary" id="upload-new-btn">Upload New Image</button>
            </div>
        </div>

        <!-- Step 3: Results -->
        <div class="section hidden" id="results-section">
            <div class="section-title">Step 3: Your Results</div>
            
            <div class="results-container">
                <div class="result-card">
                    <div class="result-title">Color Vision Type</div>
                    <div class="result-value" id="result-class">--</div>
                </div>

                <div class="result-card">
                    <div class="result-title">Accuracy Score</div>
                    <div class="result-value" id="result-accuracy">--%</div>
                </div>

                <div class="result-card">
                    <div class="result-title">Severity</div>
                    <div class="result-value" id="result-severity" style="font-size: 1.2em;">--</div>
                </div>

                <div class="result-card">
                    <div class="result-title">Confidence</div>
                    <div id="result-confidence" class="chart-container"></div>
                </div>

                <div id="result-recommendation" class="recommendation hidden"></div>
                
                <!-- Gemini AI Analysis Section -->
                <div id="gemini-analysis" class="gemini-analysis hidden">
                    <div class="gemini-header">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" style="margin-right: 8px;">
                            <path d="M12 2L2 7L12 12L22 7L12 2Z" fill="#4285F4"/>
                            <path d="M2 17L12 22L22 17L12 12L2 17Z" fill="#34A853"/>
                            <path d="M2 12L12 17L22 12" stroke="#FBBC04" stroke-width="2"/>
                        </svg>
                        <h3>Gemini AI Medical Analysis</h3>
                    </div>
                    <div id="gemini-content" class="gemini-content">
                        <div class="loading-spinner"></div>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button class="button" id="test-again-btn">Take Test Again</button>
                <button class="button" id="distractor-btn">Try Harder Test (Distractors)</button>
                <button class="button" id="luminance-btn">Try Luminance Test</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let sessionId = null;
        let testSpec = null;
        let userOrder = [];
        let draggedElement = null;

        // DOM elements
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const uploadSection = document.getElementById('upload-section');
        const testSection = document.getElementById('test-section');
        const resultsSection = document.getElementById('results-section');
        const patchGrid = document.getElementById('patch-grid');
        const orderingZone = document.getElementById('ordering-zone');
        const submitBtn = document.getElementById('submit-btn');
        const resetBtn = document.getElementById('reset-btn');
        const uploadNewBtn = document.getElementById('upload-new-btn');
        const testAgainBtn = document.getElementById('test-again-btn');
        const distractorBtn = document.getElementById('distractor-btn');
        const luminanceBtn = document.getElementById('luminance-btn');

        const API_BASE = 'http://localhost:8000';

        // Upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });

        // Helper function to resize images on client side
        function resizeImage(file, maxWidth, maxHeight, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions
                        if (width > height) {
                            if (width > maxWidth) {
                                height = height * (maxWidth / width);
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = width * (maxHeight / height);
                                height = maxHeight;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        canvas.toBlob((blob) => {
                            resolve(new File([blob], file.name, {
                                type: 'image/jpeg',
                                lastModified: Date.now()
                            }));
                        }, 'image/jpeg', quality);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function handleFileSelect() {
            const file = fileInput.files[0];
            if (!file) return;

            // Show loading
            document.getElementById('upload-loading').classList.remove('hidden');
            document.getElementById('upload-error').classList.add('hidden');

            try {
                // Resize large images on client side for faster upload
                let fileToUpload = file;
                if (file.size > 500000) { // If larger than 500KB
                    console.log('Large image detected, resizing before upload...');
                    fileToUpload = await resizeImage(file, 800, 800, 0.85);
                    console.log(`Resized from ${file.size} to ${fileToUpload.size} bytes`);
                }
                
                const formData = new FormData();
                formData.append('file', fileToUpload);

                console.log('=== UPLOAD START ===');
                console.log('File:', file.name, file.type, file.size, 'bytes');
                console.log('API URL:', `${API_BASE}/upload-image`);

                // Create abort controller for timeout (2 minutes for large images)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.warn('Upload timeout - aborting request');
                    controller.abort();
                }, 120000); // 2 minute timeout

                const response = await fetch(`${API_BASE}/upload-image`, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'Accept': 'application/json',
                    },
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                console.log('Timeout cleared successfully');
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('Error response:', errorData);
                    throw new Error(`Upload failed (${response.status}): ${errorData}`);
                }

                const data = await response.json();
                console.log('Response data:', data);
                
                if (!data.session_id || !data.test_spec) {
                    throw new Error('Invalid response: missing session_id or test_spec');
                }
                
                sessionId = data.session_id;
                testSpec = data.test_spec;

                console.log('=== UPLOAD SUCCESS ===');
                console.log('Session ID:', sessionId);
                console.log('Test spec:', testSpec);

                showTestSection();
            } catch (error) {
                console.error('=== UPLOAD ERROR ===');
                console.error('Error type:', error.name);
                console.error('Error:', error);
                console.error('Stack:', error.stack);
                
                let errorMessage = error.message;
                if (error.name === 'AbortError') {
                    errorMessage = 'Upload timed out (30 seconds). Image may be too large or backend is not responding.';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'Cannot connect to backend server. Is it running on http://localhost:8000?';
                }
                
                document.getElementById('upload-error').textContent = `Error: ${errorMessage}`;
                document.getElementById('upload-error').classList.remove('hidden');
            } finally {
                document.getElementById('upload-loading').classList.add('hidden');
            }
        }

        function showTestSection() {
            uploadSection.classList.add('hidden');
            testSection.classList.remove('hidden');
            resultsSection.classList.add('hidden');
            userOrder = new Array(testSpec.n_colors).fill(null);
            renderPatchGrid();
        }

        function renderPatchGrid() {
            patchGrid.innerHTML = '';
            
            // Render available colors
            testSpec.patch_configs.forEach((config, index) => {
                const rgb = config.rgb;
                const color = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

                const patch = document.createElement('div');
                patch.className = 'patch';
                patch.style.backgroundColor = color;
                patch.draggable = true;
                patch.dataset.colorIndex = config.color_index;
                patch.dataset.rgb = JSON.stringify(rgb);

                // Check if this color is already used in any slot
                const isUsed = userOrder.includes(config.color_index);
                if (isUsed) {
                    patch.classList.add('used');
                    patch.draggable = false; // Prevent dragging used colors
                }

                patch.addEventListener('dragstart', (e) => {
                    if (!patch.classList.contains('used')) {
                        draggedElement = patch;
                        patch.classList.add('dragging');
                    } else {
                        e.preventDefault();
                    }
                });

                patch.addEventListener('dragend', () => {
                    patch.classList.remove('dragging');
                });

                patchGrid.appendChild(patch);
            });

            renderOrderingZone();
        }

        function renderOrderingZone() {
            const orderedPatchesContainer = document.getElementById('ordered-patches');
            orderedPatchesContainer.innerHTML = '';

            // --- Reference Patch (fixed) ---
            const refConfig = testSpec.reference_patch || testSpec.patch_configs[0];
            const refRgb = refConfig.rgb;
            const refColor = `rgb(${refRgb[0]}, ${refRgb[1]}, ${refRgb[2]})`;

            const referencePatch = document.createElement('div');
            referencePatch.className = 'ordered-patch reference-patch';
            referencePatch.style.backgroundColor = refColor;
            referencePatch.innerHTML = `<div class="patch-index">Ref</div>`;
            referencePatch.title = "Reference Color (Fixed)";
            orderedPatchesContainer.appendChild(referencePatch);

            // --- Remaining slots (user order) ---
            for (let i = 0; i < testSpec.n_colors - 1; i++) {
                const colorIndex = userOrder[i];
                const hasColor = colorIndex !== undefined && colorIndex !== null && colorIndex >= 0;

                if (hasColor) {
                    const config = testSpec.patch_configs.find(c => c.color_index === colorIndex);
                    if (!config) continue;
                    const rgb = config.rgb;
                    const color = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

                    const orderedPatch = document.createElement('div');
                    orderedPatch.className = 'ordered-patch';
                    orderedPatch.style.backgroundColor = color;
                    orderedPatch.dataset.slotIndex = i;
                    orderedPatch.dataset.colorIndex = colorIndex;

                    const index = document.createElement('div');
                    index.className = 'patch-index';
                    index.textContent = i + 1;
                    orderedPatch.appendChild(index);

                    orderedPatch.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeFromSlot(i);
                    });

                    orderedPatch.addEventListener('dragover', (e) => e.preventDefault());
                    orderedPatch.addEventListener('drop', (e) => {
                        e.preventDefault();
                        if (draggedElement && draggedElement !== orderedPatch) addToSlot(i, draggedElement);
                    });

                    orderedPatchesContainer.appendChild(orderedPatch);
                } else {
                    const emptySlot = document.createElement('div');
                    emptySlot.className = 'empty-slot';
                    emptySlot.textContent = i + 1;
                    emptySlot.dataset.slotIndex = i;

                    emptySlot.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        emptySlot.classList.add('drag-over');
                    });

                    emptySlot.addEventListener('dragleave', () => emptySlot.classList.remove('drag-over'));
                    emptySlot.addEventListener('drop', (e) => {
                        e.preventDefault();
                        emptySlot.classList.remove('drag-over');
                        if (draggedElement) addToSlot(i, draggedElement);
                    });

                    orderedPatchesContainer.appendChild(emptySlot);
                }
            }

            const filledCount = userOrder.filter(x => x !== undefined && x !== null && x >= 0).length;
            submitBtn.disabled = filledCount !== (testSpec.n_colors - 1);
        }


        function addToSlot(slotIndex, element) {
            if (!element || !element.dataset || !element.dataset.colorIndex) {
                return;
            }
            
            const colorIndex = parseInt(element.dataset.colorIndex);
            
            // Validate color index
            if (isNaN(colorIndex) || colorIndex < 0) {
                return;
            }
            
            // Check if from available colors
            if (element.classList.contains('patch')) {
                // Check if this color is already used in another slot
                const existingSlotIndex = userOrder.findIndex((c, idx) => c === colorIndex && idx !== slotIndex);
                
                if (existingSlotIndex !== -1) {
                    // Color already used - show error
                    document.getElementById('test-error').textContent = 'This color is already used! Each color can only be used once.';
                    document.getElementById('test-error').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('test-error').classList.add('hidden');
                    }, 3000);
                    return;
                }
                
                // If slot is already filled, we're replacing it
                // The old color will become available again
                userOrder[slotIndex] = colorIndex;
                
                // Re-render everything to update states
                renderPatchGrid();
            }
        }

        function removeFromSlot(slotIndex) {
            // Set slot to null (not undefined) to maintain array structure
            if (slotIndex >= 0 && slotIndex < userOrder.length) {
                userOrder[slotIndex] = null;
                renderPatchGrid(); // Re-render to unmark as used
            }
        }

        submitBtn.addEventListener('click', submitResponse);

        async function submitResponse() {
            try {
                // Filter out nulls and send only the color order
                const finalOrder = userOrder.filter(x => x !== null);
                
                const response = await fetch(`${API_BASE}/submit-response?session_id=${sessionId}&user_order=${JSON.stringify(finalOrder)}`, {
                    method: 'POST',
                });

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const data = await response.json();
                showResults(data);
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('test-error').textContent = `Error: ${error.message}`;
                document.getElementById('test-error').classList.remove('hidden');
            }
        }

        function showResults(data) {
            console.log('Full response data:', data); // Debug log
            
            testSection.classList.add('hidden');
            resultsSection.classList.remove('hidden');

            // Hide ML classification sections (we only use Gemini AI now)
            document.querySelector('.results-container').style.display = 'none';
            
            // Show ONLY Gemini AI Analysis
            displayGeminiAnalysis(data.gemini_analysis);
        }
        
        function displayGeminiAnalysis(geminiData) {
            const geminiSection = document.getElementById('gemini-analysis');
            const geminiContent = document.getElementById('gemini-content');
            
            console.log('=== DISPLAY GEMINI ANALYSIS ===');
            console.log('geminiData:', geminiData);
            console.log('geminiData.success:', geminiData?.success);
            console.log('geminiData.ai_analysis exists:', !!geminiData?.ai_analysis);
            console.log('ai_analysis length:', geminiData?.ai_analysis?.length);
            
            if (!geminiData) {
                console.log('No geminiData - hiding section');
                geminiSection.classList.add('hidden');
                return;
            }
            
            console.log('Removing hidden class from gemini section');
            geminiSection.classList.remove('hidden');
            
            if (geminiData.success && geminiData.ai_analysis) {
                console.log('SUCCESS! Formatting and displaying AI analysis...');
                // Format the AI analysis with markdown-like rendering
                const formattedAnalysis = formatGeminiAnalysis(geminiData.ai_analysis);
                console.log('Formatted HTML length:', formattedAnalysis.length);
                geminiContent.innerHTML = formattedAnalysis;
                console.log('Content inserted into DOM');
            } else {
                console.log('FAILED - showing error message');
                console.log('success:', geminiData.success, 'has ai_analysis:', !!geminiData.ai_analysis);
                geminiContent.innerHTML = `
                    <div class="gemini-error">
                        <strong>‚ö†Ô∏è AI Analysis Unavailable</strong>
                        <p>${geminiData.error || 'Gemini AI is not configured. Please set GEMINI_API_KEY in backend/.env file.'}</p>
                        <p style="margin-top: 10px; font-size: 0.9em;">
                            Get your free API key from: 
                            <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #1a73e8;">
                                Google AI Studio
                            </a>
                        </p>
                    </div>
                `;
            }
            console.log('=== END DISPLAY ===');
        }
        
        function formatGeminiAnalysis(text) {
            // Simple markdown-like formatting
            let formatted = text
                // Bold text
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                // Headers
                .replace(/^### (.+)$/gm, '<h4>$1</h4>')
                .replace(/^## (.+)$/gm, '<h3 style="color: #1a73e8; font-size: 1.2em;">$1</h3>')
                .replace(/^# (.+)$/gm, '<h2 style="color: #1a73e8; font-size: 1.4em;">$1</h2>')
                // Bullet points
                .replace(/^- (.+)$/gm, '<li>$1</li>')
                .replace(/^‚Ä¢ (.+)$/gm, '<li>$1</li>')
                // Numbered lists
                .replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
            
            // Wrap consecutive <li> in <ul>
            formatted = formatted.replace(/(<li>.*<\/li>\s*)+/gs, match => `<ul>${match}</ul>`);
            
            // Add line breaks for paragraphs
            formatted = formatted.replace(/\n\n/g, '<br><br>');
            
            return formatted;
        }

        resetBtn.addEventListener('click', () => {
            userOrder = new Array(testSpec.n_colors).fill(null);
            renderPatchGrid();
            submitBtn.disabled = true;
            document.getElementById('test-error').classList.add('hidden');
        });

        uploadNewBtn.addEventListener('click', () => {
            fileInput.value = '';
            uploadSection.classList.remove('hidden');
            testSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            sessionId = null;
            testSpec = null;
        });

        testAgainBtn.addEventListener('click', () => {
            showTestSection();
        });

        distractorBtn.addEventListener('click', async () => {
            try {
                const response = await fetch(`${API_BASE}/generate-distractor-test?session_id=${sessionId}`, {
                    method: 'POST',
                });
                if (response.ok) {
                    alert('Distractor test variant generated! (Feature expansion)');
                }
            } catch (error) {
                console.error('Error:', error);
            }
        });

        luminanceBtn.addEventListener('click', async () => {
            try {
                const response = await fetch(`${API_BASE}/generate-luminance-test?session_id=${sessionId}`, {
                    method: 'POST',
                });
                if (response.ok) {
                    alert('Luminance-equalized test variant generated! (Feature expansion)');
                }
            } catch (error) {
                console.error('Error:', error);
            }
        });
    </script>
</body>
</html>